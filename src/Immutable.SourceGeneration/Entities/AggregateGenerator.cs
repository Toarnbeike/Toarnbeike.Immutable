using System.Diagnostics.CodeAnalysis;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using Toarnbeike.Immutable.SourceGeneration.Extensions;

namespace Toarnbeike.Immutable.SourceGeneration.Entities;

/// <summary>
/// Generates a partial implementation of an Entity{TKey},
/// given that the entity contains an [Aggregate] attribute.
/// Provides private constructors and static factory methods. 
/// </summary>
[Generator]
[ExcludeFromCodeCoverage]
public class AggregateGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        //if (!Debugger.IsAttached) Debugger.Launch();

        var aggregates = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                AggregateInfo.AggregateAttributeFqn,
                predicate: static (node, _) => true,
                transform: (ctx, _) => AggregateInfo.Create((INamedTypeSymbol)ctx.TargetSymbol)
            ).Where(static aggregate => aggregate is not null);

        context.RegisterSourceOutput(aggregates, static (spc, aggregate) => Execute(spc, aggregate!));
    }

    private static void Execute(SourceProductionContext context, AggregateInfo aggregateInfo)
    {
        var aggregatePartial = GenerateAggregateImplementation(aggregateInfo);
        var aggregatePartialFileName = $"{aggregateInfo.Namespace}.{aggregateInfo.Name}.g.cs";
        context.AddSource(aggregatePartialFileName, SourceText.From(aggregatePartial, Encoding.UTF8));

        var repoPartial = GenerateRepositoryImplementation(aggregateInfo);
        var repoPartialFileName = $"{aggregateInfo.Namespace}.{aggregateInfo.Name}Repository.g.cs";
        context.AddSource(repoPartialFileName, SourceText.From(repoPartial, Encoding.UTF8));
    }

    private static string GenerateAggregateImplementation(AggregateInfo aggregateInfo)
    {
        var createNewParameters = aggregateInfo.Properties.ToParameterList(includeDefault: true);
        var createNewConstructorParameters = string.Join(", ", aggregateInfo.Properties
            .Where(p => !p.HasDefaultValue && !p.IsReadOnly)
            .Select(p => p.Name.ToParameterName()));

        var createExistingParameters = aggregateInfo.Properties.ToParameterList(
            prefix: $"{aggregateInfo.EntityKeyInfo.Name} id", includeDefault: true);
        var createExistingConstructorParameters = "id" + (string.IsNullOrEmpty(createNewConstructorParameters) ? "" : ", " + createNewConstructorParameters);
        
        var newConstructorParams = aggregateInfo.Properties.ToParameterList();
        var existingConstructorParams = aggregateInfo.Properties.ToParameterList(
            prefix: $"{aggregateInfo.EntityKeyInfo.Name} id", includeDefault: false);
        
        var notNullAssignment = aggregateInfo.Properties.ToNotNullAssignments("entity");
        var constructorAssignments = aggregateInfo.Properties.ToAssignments();
        
        return $$"""
                 // <auto-generated />
                 // generator: Toarnbeike.Immutable.SourceGeneration.Entities.AggregateGenerator
                 #nullable enable

                 using {{aggregateInfo.EntityKeyInfo.Namespace}};

                 namespace {{aggregateInfo.Namespace}};
                 public partial record {{aggregateInfo.Name}}
                 {
                     /// <summary>
                     /// Create a new instance of the {{aggregateInfo.Name}}.
                     /// </summary>
                     public static {{aggregateInfo.Name}} CreateNew({{createNewParameters}})
                     {
                         var entity = new {{aggregateInfo.Name}}({{createNewConstructorParameters}});
                 {{notNullAssignment}}
                         return entity;
                     }
                     
                     /// <summary>
                     /// Recreate an existing instance of the {{aggregateInfo.Name}}.
                     /// </summary>
                     public static {{aggregateInfo.Name}} CreateExisting({{createExistingParameters}})
                     {
                         var entity = new {{aggregateInfo.Name}}({{createExistingConstructorParameters}});
                 {{notNullAssignment}}
                         return entity;
                     }

                     private {{aggregateInfo.Name}}({{existingConstructorParams}}) : base(id)
                     {
                        {{constructorAssignments}}
                     }

                     private {{aggregateInfo.Name}}({{newConstructorParams}})
                     {
                        {{constructorAssignments}}
                     }
                 }
                 """;
    }

    private static string GenerateRepositoryImplementation(AggregateInfo aggregateInfo)
    {
        var repoName = $"{aggregateInfo.Name}Repository";
        var genericTypeCouple = $"<{aggregateInfo.Name}, {aggregateInfo.EntityKeyInfo.Name}>";
        var dictionaryTypeCouple = $"<{aggregateInfo.EntityKeyInfo.Name}, {aggregateInfo.Name}>";
        
        return $$"""
                // <auto-generated />
                // generator: Toarnbeike.Immutable.SourceGeneration.Entities.AggregateGenerator
                #nullable enable
                
                using {{aggregateInfo.EntityKeyInfo.Namespace}};
                using Toarnbeike.Immutable.Mutations;
                using Toarnbeike.Immutable.Repositories;
                
                namespace {{aggregateInfo.Namespace}};
                
                public partial interface I{{repoName}} : IAggregateRepository{{genericTypeCouple}};
                
                public partial class {{repoName}} : AggregateRepository{{genericTypeCouple}}, I{{repoName}}
                {
                    public {{repoName}}(IMutationStore mutationStore) : base(mutationStore)
                    {
                        Entities = new Dictionary{{dictionaryTypeCouple}}();
                    }
                }
                """;
    }
}