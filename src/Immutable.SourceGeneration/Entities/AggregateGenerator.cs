using System.Diagnostics.CodeAnalysis;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using Toarnbeike.Immutable.SourceGeneration.Extensions;

namespace Toarnbeike.Immutable.SourceGeneration.Entities;

/// <summary>
/// Generates a partial implementation of an Entity{TKey},
/// given that the entity contains an [Aggregate] attribute.
/// Provides private constructors and static factory methods. 
/// </summary>
[Generator]
[ExcludeFromCodeCoverage]
public class AggregateGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        //if (!Debugger.IsAttached) Debugger.Launch();

        var aggregates = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                AggregateInfo.AggregateAttributeFqn,
                predicate: static (node, _) => true,
                transform: (ctx, _) => AggregateInfo.Create((INamedTypeSymbol)ctx.TargetSymbol)
            ).Where(static aggregate => aggregate is not null);

        context.RegisterSourceOutput(aggregates, static (spc, aggregate) => Execute(spc, aggregate!));
    }

    private static void Execute(SourceProductionContext context, AggregateInfo aggregateInfo)
    {
        var aggregatePartial = GenerateAggregateImplementation(aggregateInfo);
        var aggregatePartialFileName = $"{aggregateInfo.Namespace}.{aggregateInfo.Name}.g.cs";
        context.AddSource(aggregatePartialFileName, SourceText.From(aggregatePartial, Encoding.UTF8));

        var repoPartial = GenerateRepositoryImplementation(aggregateInfo);
        var repoPartialFileName = $"{aggregateInfo.Namespace}.{aggregateInfo.Name}Repository.g.cs";
        context.AddSource(repoPartialFileName, SourceText.From(repoPartial, Encoding.UTF8));
    }

    private static string GenerateAggregateImplementation(AggregateInfo aggregateInfo)
    {
        var props = aggregateInfo.Properties.Where(prop => !prop.IsReadOnly).ToList();

        var newParams = props.ToParameterList();
        var assignments = props.ToAssignments();

        // Existing params also contains the EntityId as constructor parameter.
        var existingParams = $"{aggregateInfo.Name}Id id" +
                             (props.Count > 0 ? ", " + newParams : "");

        return $$"""
                 // <auto-generated />
                 // generator: Toarnbeike.Immutable.SourceGeneration.Entities.AggregateGenerator
                 #nullable enable

                 using {{aggregateInfo.EntityKeyInfo.Namespace}};

                 namespace {{aggregateInfo.Namespace}};
                 public partial record {{aggregateInfo.Name}}
                 {
                     /// <summary>
                     /// Create a new instance of the {{aggregateInfo.Name}}.
                     /// </summary>
                     public static {{aggregateInfo.Name}} CreateNew({{newParams}}) =>
                         new({{string.Join(", ", props.Select(p => p.Name.ToParameterName()))}});

                     /// <summary>
                     /// Recreate an existing instance of the {{aggregateInfo.Name}}.
                     /// </summary>
                     public static {{aggregateInfo.Name}} CreateExisting({{aggregateInfo.EntityKeyInfo.Name}} id{{(props.Count > 0 ? ", " + newParams : "")}}) =>
                         new(id{{(props.Count > 0 ? ", " + string.Join(", ", props.Select(p => p.Name.ToParameterName())) : "")}});

                     private {{aggregateInfo.Name}}({{existingParams}}) : base(id)
                     {
                 {{assignments}}
                     }

                     private {{aggregateInfo.Name}}({{newParams}})
                     {
                 {{assignments}}
                     }
                 }
                 """;
    }

    private static string GenerateRepositoryImplementation(AggregateInfo aggregateInfo)
    {
        var repoName = $"{aggregateInfo.Name}Repository";
        var genericTypeCouple = $"<{aggregateInfo.Name}, {aggregateInfo.EntityKeyInfo.Name}>";
        var dictionaryTypeCouple = $"<{aggregateInfo.EntityKeyInfo.Name}, {aggregateInfo.Name}>";
        
        return $$"""
                // <auto-generated />
                // generator: Toarnbeike.Immutable.SourceGeneration.Entities.AggregateGenerator
                #nullable enable
                
                using {{aggregateInfo.EntityKeyInfo.Namespace}};
                using Toarnbeike.Immutable.Mutations;
                using Toarnbeike.Immutable.Repositories;
                
                namespace {{aggregateInfo.Namespace}};
                
                public partial interface I{{repoName}} : IAggregateRepository{{genericTypeCouple}};
                
                public partial class {{repoName}} : AggregateRepository{{genericTypeCouple}}, I{{repoName}}
                {
                    public {{repoName}}(IMutationStore mutationStore) : base(mutationStore)
                    {
                        Entities = new Dictionary{{dictionaryTypeCouple}}();
                    }
                }
                """;
    }
}