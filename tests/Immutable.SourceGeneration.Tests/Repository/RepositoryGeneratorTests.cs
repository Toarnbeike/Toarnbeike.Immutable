using Toarnbeike.Immutable.SourceGeneration.Repositories;
using Toarnbeike.Immutable.SourceGeneration.TypeInformation;

namespace Toarnbeike.Immutable.SourceGeneration.Tests.Repository;

public class RepositoryGeneratorTests
{
    private readonly AggregateInfo _aggregateInfo;

    private readonly PropertyInfo _settableProperty =
        new("Name", "string", false, false, false);

    private readonly PropertyInfo _readOnlyProperty =
        new("Calculated", "int", true, false, true);

    private readonly PropertyInfo _defaultValueTypeProperty =
        new("Value", "int", false, true, true);

    private readonly PropertyInfo _defaultReferenceProperty =
        new("Reference", "string", false, true, false);

    public RepositoryGeneratorTests()
    {
        List<PropertyInfo> properties = 
            [_settableProperty, _readOnlyProperty, _defaultValueTypeProperty, _defaultReferenceProperty];
        var entityKeyInfo = new EntityKeyInfo("AggregateKey", "KeyNamespace");
        _aggregateInfo = new AggregateInfo("AggregateEntity", "AggregateNamespace", entityKeyInfo, properties);
    }
    
    [Fact]
    public void FileName_Should_IncludeNamespace()
    {
        var result = RepositoryGenerator.FileName(_aggregateInfo);
        result.ShouldNotBeNull();
        result.ShouldContain(_aggregateInfo.Namespace);
    }

    [Fact]
    public void FileName_Should_IncludeName()
    {
        var result = RepositoryGenerator.FileName(_aggregateInfo);
        result.ShouldContain(_aggregateInfo.Name);
    }

    [Fact]
    public void FileName_Should_IncludeCorrectFileExtension()
    {
        var result = RepositoryGenerator.FileName(_aggregateInfo);
        result.ShouldEndWith("Repository.g.cs");
    }
    
    [Fact]
    public void Execute_Should_IncludeGeneratorInformation()
    {
        var result = RepositoryGenerator.Execute(_aggregateInfo);
        result.ShouldNotBeNull();
        result.ShouldContain("// <auto-generated />");
        result.ShouldContain(typeof(RepositoryGenerator).FullName!);
    }

    [Fact]
    public void Execute_Should_IncludeStaticUsings()
    {
        var result = RepositoryGenerator.Execute(_aggregateInfo);
        result.ShouldContain("using Toarnbeike.Immutable.Internal;");
        result.ShouldContain("using Toarnbeike.Immutable.Mutations;");
        result.ShouldContain("using Toarnbeike.Immutable.Repositories;");
    }
    
    [Fact]
    public void Execute_Should_IncludeNamespaceOfKey_AsUsing()
    {
        var result = RepositoryGenerator.Execute(_aggregateInfo);
        result.ShouldContain($"using KeyNamespace;");
    }
    
    [Fact]
    public void Execute_Should_IncludeCorrectNamespace()
    {
        var result = RepositoryGenerator.Execute(_aggregateInfo);
        result.ShouldContain($"namespace AggregateNamespace");
    }

    [Fact]
    public void Execute_Should_IncludePartialInterfaceDefinition()
    {
        var result = RepositoryGenerator.Execute(_aggregateInfo);
        result.ShouldContain($"public partial interface IAggregateEntityRepository : IAggregateRepository<AggregateEntity, AggregateKey>;");
    }
    
    [Fact]
    public void Execute_Should_IncludePartialClassDefinition()
    {
        var result = RepositoryGenerator.Execute(_aggregateInfo);
        result.ShouldContain($"public partial class AggregateEntityRepository : AggregateRepository<AggregateEntity, AggregateKey>, IAggregateEntityRepository");
    }

    [Fact]
    public void Execute_Should_IncludeConstructor_ThatRequiresMutationStoreAndDataContext()
    {
        var result = RepositoryGenerator.Execute(_aggregateInfo);
        result.ShouldContain($"public AggregateEntityRepository(IMutationStore mutationStore, IDataContext dataContext) : base(mutationStore)");
    }

    [Fact]
    public void Execute_Should_IncludeSetterForEntities()
    {
        var result = RepositoryGenerator.Execute(_aggregateInfo);
        result.ShouldContain("Entities = dataContext.AggregateEntitys;");
    }
}